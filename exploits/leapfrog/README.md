# leap-frog - picoCTF2019 - Points: 300 - Binary Exploitation
## Description
Can you jump your way to win in the following [program](https://2019shell1.picoctf.com/static/3fd6e8f58f81445720441473e2947242/rop) and get the flag? You can find the program in /problems/leap-frog_6_772f62cb51a325a368a9d1563bf4058a on the shell server? [Source](https://2019shell1.picoctf.com/static/3fd6e8f58f81445720441473e2947242/rop.c).

## Hint
Try and call the functions in the correct order!  
Remember, you can always call main() again!

## Solution
This is a pretty straightforward ROP challenge, but there are some extra challenges. The stack buffer overflow occurs in the ```vuln``` function. The goal is to set 3 boolean values (```win1```, ```win2```, and ```win3```) and then call the ```display_flag``` function. There are three functions that are designed to set these values, but the function that sets win3 has an impossible condition before it, and jumping past that check isn't easy because the code is PIE (i.e. it uses ```__x86.get_pc_thunk```). Two of the helper function also have ```leave``` before ```ret```, making it inconvenient to not know the exact address on the stack. The intended solution is to call these 3 functions to set the values and then get the flag. I guess this is possible (perhaps with a ROP NOP sled), but I wanted to make a more general exploit. I've also seen an elegant solution that use ```gets``` to overwrite the booleans in another write-up; this is perhaps the quickest option.

Instead, I opted to make a general purpose solution that gives the most freedom. Since the binary is relatively small, the number of gadgets is very limited. I decided to leak the libc address to get access to more gadgets. By returning to the ```printf``` call in the ```vuln``` function, I was able to leak the address, read a second buffer at bottom of the stack, and stack pivot easily. The second buffer then sets the booleans and calls the function that prints the flag.

## Setup
I ran the binary in one terminal window and GDB in another. The exploit has ```raw_input``` to attach the debugger. I used the following command:

```bash
gdb -p `pidof rop` -ex 'break *0x080486b3' -ex 'c'
```

There are certain parts of the code that are commented out, because they are needed when running the exploit on the picoCTF server, but not locally. This version works locally for me; if it doesn't for you, it's probably due to having a different libc version. In that case, replace the local gadget offsets, which should be present in most libc versions.
